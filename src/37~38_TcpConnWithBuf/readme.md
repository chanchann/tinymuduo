# 1.TcpConnection写数据时的要点
* 1.小流量的数据传输，可以直接全部写入内核缓存区，而不会造成内核缓存区写满的情况；所以此时不用关注POLLOUT事件，也不用考虑应用层Buffer。
* 2.大流量的数据传输，可能会出现内核缓存写满的情况；此时多余的数据会保存到应用层Buffer，而如果用户一直试图发送数据，大量数据发送不出去，会使内存撑爆————此时我们需要设置```writeCompleteCallback_```，在**所有数据写入内核缓冲区**或者**应用层Buffer清空时**回调，来提示用户可以再次发送数据。
* 3.应用层只调用```send()```函数。先尝试直接写入内核缓存区，如果空间不够，则将剩下的保存到应用层Buffer，并关注POLLOUT事件；可写时，会调用```handleWrite()```，在其中继续尝试写完剩下的数据，并且检查状态。

# 2.TcpConnection关闭时传输上的细节
* 1.用户调用```shutdown()```时，可能应用层Buffer中的数据还未发送完（即此时还在关注对应socket的POLLOUT事件）；此时只会更改连接状态到```kDisconnecting```，而在最后一次```send()```中数据写完后，会检查连接状态，如果是```kDisconnecting```，则真正关闭连接。
* 2.由于是服务器主动调用```shutdown()```关闭连接，客户端的read()会返回0，它会关闭掉连接；此时，服务器会在对应的socket上收到 POLLHUP ｜ POLLIN 事件，再调用```handleRead()```，返回0，最终关闭掉该连接。