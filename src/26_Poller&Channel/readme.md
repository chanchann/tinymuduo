# 1.PollPoller整体架构
这里的```Channel```使用了之前的```pollfd```结构体，大同小异。还是调用```poll()```来监听事件数组。之前是直接通过```pollfd```返回的事件，来完成对对应的```fd```的操作；这里是使用```Channel```来进行了包装，起到了更安全更方便的作用。

另外，增加了“暂时不关注该fd”的功能。
```cpp
// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
if (channel->isNoneEvent())
{
    // 暂时忽略该文件描述符的事件
    pfd.fd = -channel->fd()-1;	// 这样子设置是为了removeChannel优化
}
```

# 2.如何做到安全
既然对```fd```进行了包装，那么它和```Channel```就有了一一对应关系。
Muduo使用：
    1.```Channel```中包含一个```fd```，建立```Channel```到```fd```的关联；
    2.一个```Map<int, channel*>```来建立```fd```到```Channel```的关联；


一旦加入事件数组，```Channel```和事件数组中的```pollfd```也就有了一一对应关系.

1.```Channel```中也包含一个```index```，建立```Channel```到数组中```pollfd```的关联；如在```update()```时使用```index```去更改对应的```pollfd```；

2.```pollfd```到```Channel```的关联，也是通过```Map<int, channel*>```来建立；如在```fillActiveChannels()```时，使用```Map<int, channel*>```去找到有事件返回的```pollfd```所对应的```Channel```；

这样，每次有操作，都会在这几个方向上做对应的检查，确保各对象之间的对应关系，并且能高效地找到对应目标。

# 3.如何做到高效
首先结构上，没有其他的变化，只是多了一个```Map<int, channel*>```。但是其操作时间复杂度都是```O(1)```的。

在从事件数组中删除某```pollfd```时，如果直接删除，有两个不好的后果：
* 1.数组中的元素下标会改变，这样```Channel```到数组中```pollfd```的关联就会失效；
* 2.涉及大量元素的搬移，时间复杂度太高；

所以这里采用了经典的“先交换再删除”的方法：把要删除的元素与尾部元素交换，再```pop_back()```，这样时间复杂度是```O(1)```。

我们仍然需要记录下```index```的改变。假设要删除的元素为$x$，末尾元素为$tail$，所以要通过```Map<int, channel*>```找到$tail$对应的```Channel```，将其中的```index```更改为$x$的```index```。

这样，就明白为什么暂不关注时，为什么不直接设置为-1了。
```cpp
// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
if (channel->isNoneEvent())
{
    // 暂时忽略该文件描述符的事件
    pfd.fd = -channel->fd()-1;	// 这样子设置是为了removeChannel优化
}
```
因为如果设置为-1，在交换时末尾元素恰好是这样的事件，那么我们就无法去通过此```fd```去找到对应的```Channel```，从而更改其中的```index```。
而像上面这样设置，我们在发现末尾元素小于0时，直接取反就可以知道其原来的```fd```了。

# 4.EpollPoller整体架构
这里的```EpollPoller```和```PollPoller```的结构很像，主要差别是在于他们的内部实现，比如前者的```index```不再用于表示对应结构体的下标，而是用于标识当前```Channel```和```fd```的状态。
* 1.之前```update()```时使用```index```去更改对应的```pollfd```；现在由于```EpollPoller```中是使用```epoll_ctl_...()```系列函数去改变状态，所以无需```index```去标识位置了，但是需要其去标识当前状态，从而去确定该调用哪个函数。

* 2.显然，```Map<int, channel*>```也不需要了，因为结构体里的泛型指针已经指向了对应的```Channel```，所以只是起检查作用。