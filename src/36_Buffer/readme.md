# 1.Buffer的构成
* 1. 用```std::vector<char> buffer_```代替```char buf[BUFSIZE]```。变长。
* 2. ```vector```在重新分配空间后会导致原有迭代器失效，所以用```begin() + idx```的方式来记录位置。
```
/// A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer
///
/// @code
/// +-------------------+------------------+------------------+
/// | prependable bytes |  readable bytes  |  writable bytes  |
/// |                   |     (CONTENT)    |                  |
/// +-------------------+------------------+------------------+
/// |                   |                  |                  |
/// 0      <=      readerIndex   <=   writerIndex    <=     size
/// @endcode
```

# 2.为什么非阻塞IO模式下需要应用层的Buffer
分别考虑读写时的情况：
* 1. 从内核缓冲区读取数据时，可能出现粘包的情况；我们需要等下一次新的数据到来，才能获取到完整的一个或几个包；非阻塞情况下，不会有等待的情况；所以要在应用层的Buffer中保存下来，以便提供给用户判断是否完整。
* 2. 往内核缓冲区写入数据时，可能出现内核缓存空间不足的情况；非阻塞情况下，不会有等待的情况；所以我们要将未写入的数据保存在应用层的Buffer中，监听POLLOUT事件，在有空间时继续写入。
* 3. 阻塞IO模式下，我们可以一直等待；数据没来就等剩余的来，空间不足就等发送之后再写。但显然这样会造成效率低下。

# 3.为什么选用LT模式
* 1. 与```pollPoller```兼容。
* 2. 由于有事件就会一直提醒，所以不会出现漏掉事件的Bug；当然，这样也需要仔细考虑监听POLLOUT事件的时机，避免Busy Loop。（内核空间不足才监听）。
* 3. 虽然ET模式减少了对事件的处理次数，但由于该模式下读需要循环到返回EAGAIN（代表所有数据都读完；否则，由于下次不会再提醒，如果剩余就会漏掉）；写需要将Output Buffer写完，或者返回EAGAIN（代表内核缓存已满；否则，由于没有写满，POLLOUT事件不会再触发）——————这样显然增加了每次处理的系统调用次数，效率不一定高。
* 4. 我们在LT模式下，也能实现每次都将数据读完或者写完；所以在降低时延的同时，效率也不会低。这也是多数主流网络库的做法。