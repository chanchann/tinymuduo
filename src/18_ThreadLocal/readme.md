# 1.注意ThreadLocal的数据结构
一旦定义一个ThreadLocal对象，由于数据空间共享，之后所有的线程都有一个key；但是只有调用了value()的线程，其key才是真正指向了对象的，并且可以通过返回的引用对对象进行操作。

线程私有数据采用了一键多值的技术，即一个键对应多个值。访问数据时都是通过键值来访问，好像是对一个变量进行访问，其实是在访问不同的数据。
```cpp
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*));
```
第一个参数为指向一个键值的指针，第二个参数指明了一个destructor函数，

如果这个参数不为空，那么当每个线程结束时，系统将调用这个函数来释放绑定在这个键上的内存块。

key一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往key中填入不同的值，这就相当于提供了一个同名而不同值的全局变量，一键多值。

一键多值靠的是一个关键数据结构数组即TSD池，创建一个TSD就相当于将结构数组中的某一项设置为“in_use”，并将其索引返回给*key，然后设置清理函数。



# 2.value()函数返回值的思考
```cpp
 T& value()
  {
    T* perThreadValue = static_cast<T*>(pthread_getspecific(pkey_));      
    if (!perThreadValue) {
      T* newObj = new T();                       // 堆上数据
      pthread_setspecific(pkey_, newObj);       
      perThreadValue = newObj;
    }
    return *perThreadValue;    
  }
```
value()函数中动态分配了一个newObj指针，将它复制给一个perThreadValue指针变量，通过解引用perThreadValue返回T对象的引用。这样算不算是返回局部对象的引用呢？
    
1.这样是不算的。不能返回局部对象的引用/指针，本质原因是它引用的/指向的是**一个储存在栈内存的变量，在函数结束后马上会被销毁**。引用/指向未知的内存当然是危险的。
2.另一个角度想，分配在其他内存的对象是不是可以返回它的引用/指针呢？目前看来是这样，如下表：

|内存区|储存对象|生命周期|
|----|----|----|
|栈内存|局部非静态对象|运行到代码块时分配内存，离开代码块时销毁|
|静态内存|局部static成员、类static成员、定义在任何函数之外的变量|编译时分配内存，程序结束时销毁|
|动态内存（堆）|动态对象（new，智能指针）|运行到代码块时分配内存，程序结束时销毁|

储存在静态内存或动态内存的对象，我们就可以安全地返回其引用或指针。**但是对于new分配的动态对象，要注意在合适的地方delete。**

# 3.对于单例的再次说明
一定要注意Singleton类中那个静态成员才是单例。